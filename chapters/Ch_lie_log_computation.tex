\chapter{Numerical Approximation to Compute the Lie logarithm}\label{ch:lie_log_computation}

The problem of the computation of the logarithm computation can be stated as follows:
given $p \in \mathbb{G}$ the goal is to find $\mathbf{u}$ such that $\exp(\mathbf{u})$ is the best possible approximation of $p$.  \\
This chapter is devote to the numerical computation of the logarithm, using an iterative algorithm based on the Log-composition. In this context each of the presented techniques are suitable to perform this computation.


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% % SUBSECTION
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
\section{Tools for the Computation from Truncated Series}

\noindent
xxx These must be posed in the truncated series context after chapter 4 is investigated.\\

\noindent
We emphasize the fact that if $\mathfrak{g}$ and $\mathbb{G}$ are subset of a bigger algebra, then exp and log can be considered as infinite series.
Remarkable consequence is the approximation of $\exp(\mathbf{v})$ with $1 + \mathbf{v}$ if the transformation $\mathbf{v}$ is small. This approximation is the base of what follows in this chapter.\\
In parallel with the log computation given by:
\begin{align*}
\star : \mathfrak{g} \times \mathfrak{g} & \longrightarrow \mathfrak{g}    \\
(\mathbf{v}_{1}, \mathbf{v}_{2}) &\longmapsto \mathbf{v}_{1}\star \mathbf{v}_{2} =  \log(\exp(\mathbf{v}_1)\circ \exp(\mathbf{v}_2))
\end{align*}
we define two approximating functions:
\begin{align*}
\text{app} : \mathfrak{g} & \longrightarrow  \mathfrak{g} ^{\sim}    \\
\mathbf{u} &\longmapsto \exp(\mathbf{u}) - 1
\end{align*}
and
\begin{align*}
\text{App} : \mathbb{G} & \longrightarrow  \mathbb{G}^{\sim}   \\
\exp(\mathbf{u}) &\longmapsto 1 + \mathbf{u}
\end{align*}
Where $\mathfrak{g} ^{\sim}$ is a space of approximations of elements of $\mathfrak{g} $,and $\mathbb{G}^{\sim} $ is a space of approximations of elements in $\mathbb{G}$ (xxx that requires some more investigations and formal definition in conjunction with truncated series).\\
Consequence of this definition is the fact that
\begin{align*}
\mathbf{u} \simeq   \text{app} (\mathbf{u})
\qquad \qquad 
\exp(\mathbf{u}) \simeq   \text{App} (\exp(\mathbf{u})) 
\end{align*}
xxx errors can be investigated and maybe can become known elements in the computations! \\
The two following straightforward properties, that holds for all $\mathbf{u}, \mathbf{v} $ in the Lie algebra
\begin{enumerate}
	\item $\mathbf{u} = \mathbf{v} \star  (-\mathbf{v} \star  \mathbf{u} )$
	\item $\text{app} (\mathbf{v} \star  \mathbf{u}) = \exp(\mathbf{v})\exp(\mathbf{u}) - 1 \in \mathfrak{g} ^{\sim}$
\end{enumerate}
lead us to consider the algorithm presented in \cite{Bossa:08} under a new perspective. 

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% % SUBSECTION
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
\section{A reformulation of the Bossa Algorithm using Log-composition}

If the goal is to find $\mathbf{u}$ when its exponential is known, we can consider the sequence transformations $\{\mathbf{u}_{j}  \}_{j=0}^{\infty}$ that approximate $\mathbf{u}$ as consequence of
\begin{align*}
\mathbf{u} = \mathbf{u}_{j} \star  (-\mathbf{u}_{j}  \star  \mathbf{u} ) \Longrightarrow
\mathbf{u} \simeq \mathbf{u}_{j} \star  \text{app}(-\mathbf{u}_{j}  \star  \mathbf{u} )
\end{align*}
This suggest that a reasonable approximation for the $(j+1)$-th element of the series can be defined by
\begin{align*}
\mathbf{u}_{j+1} & :=  \mathbf{u}_{j} \star  \text{app}(-\mathbf{u}_{j}  \star  \mathbf{u} )
\end{align*}
If we chose the initial value $\mathbf{u}_{0}$ to be zero, then the algorithm presented in \cite{Bossa:08}  become:
%\begin{align*}
%p= \exp(\mathbf{v}) &= (\exp(\mathbf{v})\circ \exp(-\mathbf{v}))\circ \exp(\mathbf{v})\\
%&= \exp(\mathbf{v})\circ (\exp(-\mathbf{v})\circ p)\\
%&= \exp(\mathbf{v})\circ \exp(\delta \mathbf{v})\\
%&\approx \exp(\mathbf{v})\circ \exp(\tilde{\delta} \mathbf{v})
%\end{align*}
\begin{equation}\label{eq:bossa_reformulated}
\begin{cases}
\mathbf{u}_0 = 0 \\
\mathbf{u}_{j+1} = \mathbf{u}_{j} \star  \text{app}(-\mathbf{u}_{j}  \star  \mathbf{u} )
\end{cases}
\end{equation}
Each strategy that we have examined to compute the Lie composition, become a numerical method for the computation of the logarithm.
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% % SUBSECTION
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
\subsection{BCH Strategy}
At each step, we compute the approximation $\mathbf{v}_{j+1}$ with the $k$-th truncation of the BCH formula:
\begin{equation}\label{eq:bossa_strat}
\begin{cases}
\mathbf{u}_0 = 0 \\
\mathbf{u}_{j+1} = \text{BCH}^{k}(\mathbf{u}_{j}, \text{app}(-\mathbf{u}_{j}  \star  \mathbf{u} ))
\end{cases}
\end{equation}
thus, for the first degree we have 
\begin{align*}
	\text{BCH}^{1}(\mathbf{u}_{j}, \text{app}(-\mathbf{u}_{j}  \star  \mathbf{u} ))
	&=
	\mathbf{u}_{j} +  \text{app}(-\mathbf{u}_{j}  \star  \mathbf{u} )\\
	&=
	\mathbf{u}_{j} + \exp(-\mathbf{u}_{j}) \exp( \mathbf{u})  - 1
\end{align*}
For the second degree we have:
\begin{align*}
\text{BCH}^{2}(\mathbf{u}_{j}, \text{app}(-\mathbf{u}_{j}  \star  \mathbf{u} ))
&=
\mathbf{u}_{j} +  \text{app}(-\mathbf{u}_{j}  \star  \mathbf{u} ) + \frac{1}{2}[\mathbf{u}_{j},  \text{app}(-\mathbf{u}_{j}  \star  \mathbf{u} )]\\
&=
\mathbf{u}_{j} + \exp(-\mathbf{u}_{j}) \exp( \mathbf{u})  - 1 + \\
&+ \frac{1}{2}(  \mathbf{u}_{j}( \exp(-\mathbf{u}_{j}) \exp( \mathbf{u})  - 1) -  ( \exp(-\mathbf{u}_{j}) \exp( \mathbf{u})  - 1)\mathbf{u}_{j})
\end{align*}


%\begin{align*}
%\tilde{\delta} \mathbf{v}_{n-1} =  \exp(-\mathbf{v}_{n-1} )\circ \Phi - e
%\end{align*}
%%
%\begin{proof}  
%	Let $\mathbf{v}_{0}$ be an element of $\mathfrak{g}$ in some sense close to $\mathbf{v}$ then:
%	\begin{align*}
%	p = \exp(\mathbf{v}) &= \exp(\mathbf{v}_{0})\circ (\exp(-\mathbf{v}_{0})\circ p)
%	\end{align*}
%	We define $\delta \mathbf{v}_{0} \in\mathfrak{g}$ as $\delta \mathbf{v}_{0} = \exp(-\mathbf{v}_{0})\circ p$. Then
%	\begin{align*}
%	p &= \exp(\mathbf{v}_{0})\circ \exp(\delta \mathbf{v}_{0}) \\
%	\exp(V) &= \exp(\mathbf{v}_{0})\circ \exp(\delta \mathbf{v}_{0}) \\
%	\mathbf{v} &= \log(\exp(\mathbf{v}_{0})\circ \exp(\delta \mathbf{v}_{0}))\\
%	\mathbf{v} &\simeq \text{BCH}^{k}(\mathbf{v}_{0},\delta \mathbf{v}_{0})
%	\end{align*}
%	We approaching the tangent vector $\mathbf{v}$ using an iterative algorithm based on the $\text{BCH}$ formula and the lemma \ref{le:taylorlemma}.
%	\begin{align*}
%	\exp(\delta \mathbf{v}_{0}) \approx e + \delta \mathbf{v}_{0} \Longrightarrow \delta \mathbf{v}_{0} \approx  \exp(\delta \mathbf{v}_{0}) - e
%	\end{align*}
%	Having $\mathbf{v}_{0}$ as our initial value we define
%	\begin{align*}
%	\tilde{\delta} \mathbf{v}_{0} := \exp(\delta \mathbf{v}_{0}) - e
%	\end{align*}
%	Using $p = \exp(\mathbf{v}_{0})\circ \exp(\delta \mathbf{v}_{0})$ we can say that $\exp(\delta \mathbf{v}_{0}) =  \exp(-\mathbf{v}_{0})\circ p$ and then
%	\begin{align*}
%	\tilde{\delta} \mathbf{v}_{0} = \exp(-\mathbf{v}_{0})\circ p - e
%	\end{align*}
%	just by definition. Since $p$ is known we can start our successive approximation, and if we set $\mathbf{v}_{0} = \mathbf{0}$ we end up with the iterative algorithm (\ref{eq:bossa_strat}).
%\end{proof}

\begin{theorem}[Bossa]\label{th:bossa}
	The iterative algorithm (\ref{eq:bossa_strat}) converges to $\mathbf{v}$ with error $\delta_n \in \mathbb{G}$, where
	\begin{align*}
	\delta_{n} := \log(\exp(\mathbf{v})\circ \exp(-\mathbf{v}_{n})) \in O(\euclideanMetric{p - e}^{2^{n}})
	\end{align*}
\end{theorem}
%\begin{proof}
%	TODO See notebook or \cite{bossa}.
%\end{proof}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% % SUBSECTION
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
\subsection{Parallel Transport Strategy}

If we use the parallel transport for the computation of the log-composition, we obtain:
\begin{equation}\label{eq:parallel_strategy}
\begin{cases}
\mathbf{u}_0 = \mathbf{0} \\
\mathbf{u}_{t} = \mathbf{u}_{t-1} + \exp(-\frac{\mathbf{u}_{t-1}}{2}) \circ \exp(\delta \mathbf{u}_{t-1}) \circ \exp(\frac{\mathbf{u}_{t-1}}{2}) - e
\end{cases}
\end{equation}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% % SUBSECTION
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
\subsection{Symmetrization Strategy}

The algorithm for the computation of the group logarithm can be improved considering a symmetric version of the underpinning strategy. In this version we use the first order approximation of the BCH formula (see equation (\ref{eq:first_order_approx}) in the following proof), compensating with the fact that the symmetrization should decrease the error involved.
It gives birth to the following algorithm:
\begin{equation}\label{eq:sym_strategy}
\begin{cases}
\mathbf{v}_0 = \mathbf{0} \\
\mathbf{v}_{t+1} = \mathbf{v}_{t} + \frac{1}{2}(\tilde{\delta} \mathbf{v}^{L}_{t} +\tilde{\delta} \mathbf{v}^{R}_{t})
\end{cases}
\end{equation}
Where $\tilde{\delta} \mathbf{v}^{R}_{t} = \exp(\mathbf{v})\circ \exp(- \mathbf{v}_{t}) - e$ and $\tilde{\delta} \mathbf{v}^{L}_{t} = \exp(-\mathbf{v}_{t})\circ \exp(\mathbf{v}) - e$.\\
\begin{proof}
	To show why it works we remind that the starting point was
	\begin{align*}
	p= \exp(\mathbf{v}) &=  \exp(\mathbf{v}_{0})\circ \exp(\delta \mathbf{v}_{0})
	\end{align*}
	where $\exp(\delta \mathbf{v}_{0}) = \exp(-\mathbf{v}_{0})\circ p$.\\
	An equivalent starting point would have been $\exp(\mathbf{v}) = \exp(\delta \mathbf{v})\circ \exp(\mathbf{v}_{0})$ for $\exp(\delta \mathbf{v}) = p\circ \exp(-\mathbf{v}_{0})$. \\
	This idea leads to the definition of
	\begin{align*}
	\exp(\delta \mathbf{v}^{R}_{t}) &:= p\circ \exp(- \mathbf{v}_{t}) = \exp(\mathbf{v})\circ \exp(- \mathbf{v}_{t})\\
	\exp(\delta \mathbf{v}^{L}_{t}) &:=  \exp(- \mathbf{v}_{t}) \circ p = \exp(- \mathbf{v}_{t}) \circ \exp(\mathbf{v}) 
	\end{align*}
	It follows that 
	\begin{align*}
	\exp(\mathbf{v}) &= \exp(\mathbf{v}_{0})\circ \exp(\delta \mathbf{v}^{R}_{0})\\
	\exp(\mathbf{v}) &=  \exp(\delta \mathbf{v}^{L}_{0}) \circ \exp(\mathbf{v}_{0})
	\end{align*}
	Using $\exp(\delta \mathbf{v}^{R}_{t}) \approx e + \delta \mathbf{v}^{R}_{t}$ and $\exp(\delta \mathbf{v}^{L}_{t}) \approx e + \delta \mathbf{v}^{L}_{t}$ we can use the following approximation to define the symmetric algorithm:
	\begin{align*}
	\exp(\delta \mathbf{v}^{R}_{t}) &= \exp(\mathbf{v})\circ \exp(-\mathbf{v}_{t})\\
	e + \tilde{\delta} \mathbf{v}^{R}_{t} &= \exp(\mathbf{v})\circ \exp(- \mathbf{v}_{t})\\
	\tilde{\delta} \mathbf{v}^{R}_{t} &= \exp(\mathbf{v})\circ \exp(- \mathbf{v}_{t}) - e
	\end{align*}
	\begin{align*}
	\exp(\delta \mathbf{v}^{L}_{t}) &= \exp(- \mathbf{v}_{t}) \circ \exp(\mathbf{v})\\
	e + \tilde{\delta} \mathbf{v}^{L}_{t} &= \exp(-\mathbf{v}_{t})\circ \exp( \mathbf{v})\\
	\tilde{\delta} \mathbf{v}^{L}_{t} &= \exp(-\mathbf{v}_{t})\circ \exp(\mathbf{v}) - e
	\end{align*}
	Which gives birth to iterative algorithm, for a given initial value $V_0$:  
	\begin{equation}
	\begin{cases}
	\mathbf{v}_0  \\
	\mathbf{v}_{t+1} =\text{BCH}(\mathbf{v}_{t},\tilde{\delta} \mathbf{v}^{R}_{t})
	\end{cases}
	\begin{cases}
	\mathbf{v}_0  \\
	\mathbf{v}_{t+1} = \text{BCH}(\tilde{\delta} \mathbf{v}^{L}_{t}, \mathbf{v}_{t})
	\end{cases}
	\end{equation}
	If follows that
	\begin{align*}
	\mathbf{v}_{t+1} = \frac{1}{2}(\text{BCH}(\tilde{\delta} \mathbf{v}^{L}_{t}, \mathbf{v}_{t}) + \text{BCH}(\mathbf{v}_{t},\tilde{\delta} \mathbf{v}^{R}_{t}))
	\end{align*}
	Taking the first order approximation of the BCH formula:
	\begin{align}\label{eq:first_order_approx}
	BCH(\tilde{\delta} \mathbf{v}^{L}_{t}, \mathbf{v}_{t}) &\approx \tilde{\delta} \mathbf{v}^{L}_{t} + \mathbf{v}_{t}\\
	BCH(\mathbf{v}_{t},\tilde{\delta} \mathbf{v}^{R}_{t}) &\approx \mathbf{v}_{t} + \tilde{\delta} \mathbf{v}^{R}_{t}
	\end{align}
	we get
	\begin{align*}
	\mathbf{v}_{t+1} = \mathbf{v}_{t} + \frac{1}{2}(\tilde{\delta} \mathbf{v}^{L}_{t} + \tilde{\delta} \mathbf{v}^{R}_{t})
	\end{align*}
\end{proof}
We observe that the symmetric approach do not requires to use the BCH formula at each passage, having considered the approximation at the first order of the BCH.\\
We conclude with a formula that relates $\tilde{\delta} \mathbf{v}^{L}_{t}$ with $\tilde{\delta} \mathbf{v}^{R}_{t}$:
\begin{theorem}
	Be $\tilde{\delta} \mathbf{v}^{R}_{t} = \exp(\mathbf{v})\circ \exp(- \mathbf{v}_{t}) - e$ and $\tilde{\delta} \mathbf{v}^{L}_{t} = \exp(-\mathbf{v}_{t})\circ \exp(\mathbf{v}) - e$ as before, then
	\begin{align*}
	\delta \mathbf{v}^{L}_{t} \approx \exp(-\mathbf{v}_{t}) \circ \delta \mathbf{v}^{R}_{t} \circ \exp(\mathbf{v}_{t})
	\end{align*}
\end{theorem}
\begin{proof}
	Since $\exp(\mathbf{v}_{t})\circ \exp(\delta \mathbf{v}^{R}_{t}) \approx exp(\delta \mathbf{v}^{L}_{t}) \circ \exp(\mathbf{v}_{t})$ it follows
	\begin{align*}
	\exp(\delta \mathbf{v}^{R}_{t}) = \exp(-\mathbf{v}_{t})\circ \delta \mathbf{v}^{L}_{t} \circ \exp(\mathbf{v}_{t})
	\end{align*}
	Using $\exp(\delta \mathbf{v}^{R}_{t}) = e + \delta \mathbf{v}^{R}_{t}$ and $\exp(\delta \mathbf{v}^{L}_{t}) = e + \delta \mathbf{v}^{L}_{t}$ we get
	\begin{align*}
	e + \delta \mathbf{v}^{R}_{t} &= \exp(-\mathbf{v}_{t})\circ (e + \delta \mathbf{v}^{L}_{t}) \circ \exp(\mathbf{v}_{t})\\
	\delta \mathbf{v}^{R}_{t} &= \exp(-\mathbf{v}_{t})\circ \delta \mathbf{v}^{L}_{t} \circ \exp(\mathbf{v}_{t})
	\end{align*}
\end{proof}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% % SUBSECTION
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Symmetric-Parallel Transport Strategy}
If we are not satisfied to having take only the firs order approximation of the BCH in the equation (\ref{eq:first_order_approx}) we use at this stage the parallel transport in the method presented in this section.
Going back to the algorithm \ref{eq:sym_strategy} we can apply to
\begin{align*}
\mathbf{v}_{t+1} = \frac{1}{2}(\text{BCH}(\tilde{\delta} \mathbf{v}^{L}_{t}, \mathbf{v}_{t}) + \text{BCH}(\mathbf{v}_{t},\tilde{\delta} \mathbf{v}^{R}_{t}))
\end{align*}
the parallel transport to get
\begin{align*}
\mathbf{v}_{t+1} &= \frac{1}{2}((\tilde{\delta} \mathbf{v}^{L}_{t})^{\parallel} + \mathbf{v}_{t} + \mathbf{v}_{t} + (\tilde{\delta} \mathbf{v}^{R}_{t})^{\parallel}) \\
&= 2\mathbf{v}_{t} + \frac{1}{2}((\tilde{\delta} \mathbf{v}^{L}_{t})^{\parallel} + (\tilde{\delta} \mathbf{v}^{R}_{t})^{\parallel})
\end{align*}
Applying the definition of parallel transport we get
\begin{align*}
(\tilde{\delta} \mathbf{v}^{L}_{t})^{\parallel} + (\tilde{\delta} \mathbf{v}^{R}_{t})^{\parallel} 
= 
\exp(-\frac{\mathbf{v}_{t}}{2}) \circ (\tilde{\delta} \mathbf{v}^{L}_{t} +\tilde{\delta} \mathbf{v}^{R}_{t} )\circ \exp(\frac{\mathbf{v}_{t}}{2})
\end{align*}
where 
\begin{align*}
\tilde{\delta} \mathbf{v}^{L}_{t} &=  \exp(\mathbf{v})\circ \exp(-\mathbf{v}_{t}) - e \\
\tilde{\delta} \mathbf{v}^{R}_{t} &=  \exp(-\mathbf{v}_{t})\circ \exp(\mathbf{v}) - e
\end{align*}
Then a new improvement of the algorithm \ref{eq:bossa_strategy}  is
\begin{equation}\label{eq:sym_parallel_strategy}
\begin{cases}
\mathbf{v}_0 = 0 \\
\mathbf{v}_{t} 
=  
2\mathbf{v}_{t-1} + \frac{1}{2}(\exp(-\frac{\mathbf{v}_{t-1}}{2}) 
\circ 
(\tilde{\delta} \mathbf{v}^{L}_{t-1} +\tilde{\delta} \mathbf{v}^{R}_{t-1} )\circ \exp(\frac{\mathbf{v}_{t-1}}{2}))
\end{cases}
\end{equation}
(This must be investigated!)